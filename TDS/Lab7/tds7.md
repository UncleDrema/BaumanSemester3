# Лабораторная работа №7
## Дремин Кирилл, студент ИУ7-36Б

### Описание условия задачи
Получить навыки работы со сбалансированными деревьями и хеш-таблицами, сравнить эффективность поиска в двоичных деревьях поиска, сбалансированных деревьях поиска и хеш-таблицах. 

### Описание ТЗ
#### Описание исходных данных и результатов:
Программа реализует двоичное дерево поиска (лабораторная №6), сбалансированное дерево поиска и хеш-таблицу, содержащие в качестве ключевого значения код символа, а в качестве информационной части - число его вхождений в заданную строку.
Все три структуры данных реализуют операции добавления, удаления и поиска записи в них.

### Способ обращения к программе
Обращение происходит посредством вызова заранее скомпилированного файла и ввода через консоль

### Описание входных данных
Программа позволяет произвести анализ введённой строки, а также визуализировать используемое для работы дерево или хеш-таблицу.

```
1. Ввести строку
2. Удалить повторяющиеся буквы из строки
3. Сгенерировать случайную строку заданного размера
4. Построить двоичное дерево поиска, сбалансированное дерево поиска и хеш-таблицу по строке
5. Вывести дерево на экран (левый правый >1)
6. Добавить символ в дерево
7. Удалить символ из дерева
8. Найти символ в дереве
9. Вывести сбалансированное дерево на экран (левый правый >1)
10. Добавить символ в сбалансированное дерево
11. Удалить символ из сбалансированного дерева
12. Найти символ в сбалансированном дереве
13. Вывести хеш-таблицу
14. Добавить символ в хеш-таблицу
15. Удалить символ из хеш-таблицы
16. Найти символ в хеш-таблице
17. Провести анализ эффективности работы структур данных на основе текущей заданной строки
18. Удалить повторяющиеся буквы из двоичного дерева поиска
19. Удалить повторяющиеся буквы из сбалансированного двоичного дерева поиска
20. Удалить повторяющиеся буквы из хеш-таблицы
0. Выход из программы
```

Корректный ввод - число от 0 до 20.

#### Описание возможных аварийных ситуаций и ошибок пользователя

1. Ввод некорректных данных
2. Ошибки выделения динамической памяти
3. Указание некорректных символов при вводе
4. Запрос вывода дерева на экран при наличии в нём символов угловых скобок или амперсанда

### Описание внутренних СД
Для реализации ДДП и СДП используется АТД, описывающий операции над двоичным деревом, аналогично реализации в лабораторной №6, однако помимо этого предоставляется операция балансировки дерева:

```c

typedef struct tree_t tree_t;

/// Получить значение символа из узла
char get_char(const tree_t *node);

/// Получить число вхождений символа из узла
size_t get_count(const tree_t *node);

/// Создание дерева на основе строки
tree_t *create_tree(char *str);

/// Освобождение памяти, выделенной под дерево
void free_tree(tree_t *tree);

/// Постфиксный обход дерева
void traverse_post(tree_t *tree, void (*apply)(tree_t *, void *), void *acc);

/// Префиксный обход дерева
void traverse_pre(tree_t *tree, void (*apply)(tree_t *, void *), void *acc);

/// Инфиксный обход дерева
void traverse_in(tree_t *tree, void (*apply)(tree_t *, void *), void *acc);

/// Вставка символа в дерево
tree_t *tree_insert(tree_t *tree, char ch);

/// Удаление символа из дерева
tree_t *tree_remove(tree_t *tree, char ch);

/// Поиск узла в дереве
tree_t *tree_find(tree_t *tree, char ch);

/// Поиск узла в дереве с возвратом числа сравнений
tree_t *tree_find_get_compares(tree_t *tree, char ch, size_t *cmp_count);

/// Вывод дерева при помощи утилиты graphviz
void show_tree(tree_t *tree);

/// Копия дерева
tree_t *copy_tree(tree_t *tree);

/// Копия дерева без повторяющихся элементов
tree_t *tree_without_repeating(tree_t *tree);

/// Сбалансированная копия дерева
tree_t *balanced_tree(tree_t *tree);

/// Среднее число сравнений при поиске
float tree_avg_cmp(tree_t *tree);

/// Объём памяти, выделенной под дерево
size_t tree_sizeof(tree_t *tree);
```

Непосредственная реализация дерева:
```c
typedef struct tree_data
{
    char key;
    size_t count;
} tree_data;

struct tree_t
{
    tree_data data;
    tree_t *left;
    tree_t *right;
};

```
В данной реализации дерева символ является ключевым значением и образует вместе с количеством вхождений информационную часть узла дерева.

Операции над сбалансированным деревом не предоставляются отдельно, для упрощений интерфейса и исходя из поставленных задач для их выполнения используются обычные операции над ДДП, после которых происходит балансировка (для вставки и удаления).
Так как сложность балансировки составляет O(N*log(N)), такая же сложность справедлива для операций вставки и удаления узла, однако для операции поиска гарантированна верхняя оценка сложности log(N) за счёт идеальной балансировки дерева.

Помимо этого в программе реализована хеш-таблица на основе следующего АТД:
```c
typedef struct hashtable_t hashtable_t;

typedef struct entry_t entry_t;

/// Создать хеш-таблицу на основе строки
hashtable_t *create_table(char *str);

/// Освободить хеш-таблицу
void free_table(hashtable_t *table);

/// Поместить символ в хеш-таблицу
void hashtable_put(hashtable_t *table, char ch);

/// Поиск в записи по символу в хеш-таблице
entry_t *hashtable_find(hashtable_t *table, char ch);

/// Поиск в записи по символу в хеш-таблице с возвратом числа сравнений
entry_t *hashtable_find_get_compares(hashtable_t *table, char ch, size_t *cmp_count);

/// Удаление записи по символу из хеш-таблицы
void hashtable_remove(hashtable_t *table, char ch);

/// Получить символ из записи
char get_entry_char(const entry_t *entry);

/// Получить число вхождений из записи
size_t get_entry_count(const entry_t *entry);

/// Получить количество элементов в хеш-таблице
size_t get_len(hashtable_t *table);

/// Вывести хеш-таблицу
void print_table(hashtable_t *table);

/// Получить среднее число сравнений при поиске элементов
float hashtable_avg_cmp(hashtable_t *table);

/// Получить размер хеш-таблицы в байтах
size_t hashtable_sizeof(hashtable_t *table);

/// Удалить повторяющиеся
void hashtable_remove_repeating(hashtable_t *table);
```

Непосредственная реализация хеш-таблицы:
```c
struct hashtable_t
{
    size_t capacity;
    size_t len;
    entry_t **arr;
};

struct entry_t
{
    char ch;
    size_t count;
    entry_t *next;
};
```
В качестве метода разрешения коллизий выбрано цепное хеширование.

Непосредственно хеш-функция для ключевых значений расчитывается так:
```c
static size_t char_hash(char ch, size_t mod)
{
    return (PRIME_CONST * ch) % mod;
}
```
Где PRIME_CONST = 97, ближайшее простое число к числу допустимых в строке печатных символов (что обеспечивает хорошее распределение хешей), ch - ключевое значение, а mod - правая, не включающая граница интервала значений хеш-функции.
Данный интервал имеет следующий вид: [0, mod), значение из этого интервала является индексом в массиве списков в хеш-таблице.

Расширение внутреннего массива списков происходит при соотношении количества элементов в хеш-таблице к её вместимости как 5:1.
Данное число получено исходя из теоретических требований по рехешированию хеш-таблицы в том случае, когда среднее число сравнений превышает 3.
Данное условие выполняется при средней длине всех списков в 5 элементов (1 + 2 + 3 + 4 + 5 = 15, 15 / 5 = 3 - среднее число сравнений), однако вычисление точного значения затратно, так что происходит лишь приблизительный его анализ путём сравнения общего числа элементов и размера выделенной под массив списков памяти.

### Сравнение эффективности поиска в структурах данных
Для сравнения эффективности поиска в каждой структуре данных был 100 000 000 раз осуществлён поиск заданного символа.

В качестве исходной была использована случайная строка из 1000 разных символов.

Поиск первого встреченного в строке символа:

| Структура данных    | Время всего (мс) | Время среднее (мс) | Память (байт) | Число сравнений | Среднее число сравнений |
|---------------------|------------------|--------------------|---------------|-----------------|-------------------------|
| Бинарное ДП         | 638              | 0.00001            | 2880          | 1               | 6.5222220               |
| Сбалансированное ДП | 2622             | 0.00003            | 2880          | 6               | 5.6666665               |
| Хеш-таблица         | 872              | 0.00001            | 2376          | 1               | 2.4111111               |

Поиск случайного символа:
Символ "a" найден с количеством повторений: 4
| Структура данных    | Время всего (мс) | Время среднее (мс) | Память (байт) | Число сравнений | Среднее число сравнений |
|---------------------|------------------|--------------------|---------------|-----------------|-------------------------|
| Бинарное ДП         | 3888             | 0.00004            | 2880          | 9               | 6.5222220               |
| Сбалансированное ДП | 2993             | 0.00003            | 2880          | 7               | 5.6666665               |
| Хеш-таблица         | 901              | 0.00001            | 2376          | 2               | 2.4111111               |

Далее была использована строка, состоящая из символов с возрастающими кодами

Поиск первого символа:

| Структура данных    | Время всего (мс) | Время среднее (мс) | Память (байт) | Число сравнений | Среднее число сравнений |
|---------------------|------------------|--------------------|---------------|-----------------|-------------------------|
| Бинарное ДП         |              629 |            0.00001 |           480 |               1 |               7.9333334 |
| Сбалансированное ДП |             1789 |            0.00002 |           480 |               4 |               3.2666667 |
| Хеш-таблица         |              809 |            0.00001 |           432 |               1 |               1.8000000 |

Поиск последнего символа:

| Структура данных    | Время всего (мс) | Время среднее (мс) | Память (байт) | Число сравнений | Среднее число сравнений |
|---------------------|------------------|--------------------|---------------|-----------------|-------------------------|
| Бинарное ДП         |             8050 |            0.00008 |           480 |              14 |               7.9333334 |
| Сбалансированное ДП |             1945 |            0.00002 |           480 |               4 |               3.2666667 |
| Хеш-таблица         |             1195 |            0.00001 |           432 |               3 |               1.8000000 |

Поиск среднего символа:

| Структура данных    | Время всего (мс) | Время среднее (мс) | Память (байт) | Число сравнений | Среднее число сравнений |
|---------------------|------------------|--------------------|---------------|-----------------|-------------------------|
| Бинарное ДП         |             3133 |            0.00003 |           480 |               7 |               7.9333334 |
| Сбалансированное ДП |             1847 |            0.00002 |           480 |               4 |               3.2666667 |
| Хеш-таблица         |             1023 |            0.00001 |           432 |               2 |               1.8000000 |

### Вывод
Сбалансированное двоичное дерево в среднем случае превосходит по эффективности обычное двоичное дерево поиска по операции поиска элементов.
Однако стоит учитывать повышение затрат на поддержание балансировки. Но в целом, в рассматриваемой задаче анализа строки, операции вставки и удаления происходят не часто и за счёт разделения операций вставки и балансировки, возможно полное построение дерева и единичная балансировка после этого.
Таким образом в большинстве случаев сбалансированное дерево поиска является более эффективной структурой данных в данной задаче.

В то же время хеш-таблица позволяет реализовать ещё более эффективный анализ вхождений символов в строку за счёт поддержания инварианта максимального числа сравнений, что позволяет гарантированно быстро находить нужную запись.
Накладные расходы на расчёт хеш-функции практически незаметны, так как ключами являются символы, хеш-функция которых тривиальна.
Подводя итоги, можно сделать вывод, что для реализации описанной задачи анализа строки наиболее эффективной структурой данных является хеш-таблица.

Эффективность по памяти же для всех описанных структур данных приблизительно одинакова, однако хеш-таблица несколько более эффективна, чем деревья поиска (что достигается за счёт выбранной стратегии реструктуризации).

### Ответы на вопросы

1. ***Чем отличается идеально сбалансированное дерево от АВЛ-дерева?***
    Идеально сбалансированное дерево обеспечивает минимальную высоту дерева и требует, чтобы число узлов в левом и правом поддеревьях отличалось не более чем на единицу, в то время как АВЛ-дерево требует, чтобы высота двух поддеревьев каждого узла отличалась не более чем на единицу.
2. ***Чем отличается поиск в АВЛ-дереве от поиска в дереве двоичного поиска?***
    Поиск в АВЛ-дереве отличается тем, что в нём невозможна ситуация вырождения поддеревьев в связный список, что уменьшает его высоту
3. ***Что такое хеш-таблица, каков принцип её построения?***
    Хеш-таблица - структура данных, сопоставляющая при помощи так называемое хеш-функции ключевому значению элемента индекс массива, куда он помещается, что позволяет сразу находить его местоположение в памяти
4. ***Что такое коллизии? Каковы методы их устранения?***
    Коллизия - совпадение хешей двух значений. Есть два основных метода устранения коллизий (помимо рехеширования с увеличением объёма памяти, занимаемой хеш-таблицей): метод цепочек, при котором элементы с одинаковыми хешами помещаются в связный список и открытая адресация, при которой при обнаружении коллизии
5. ***В каком случае поиск в хеш-таблице становится неэффективен?***
    Поиск в хеш-таблице становится неэффективен при большом числе коллизий, которое ведёт к увеличению числа сравнений. Эффективность может быть восстановлена путём реструктуризации хеш-таблицы.
6. ***Эффективность поиска в АВЛ-деревьях, в дереве двоичного поиска, в хеш-таблицах***
    Наибольшая эффективность поиска согласно заданию в среднем случае достигается в хеш-таблицах за счёт константного ограничения максимального числа сравнений, меньшей эффективностью обладает сбалансированное дерево поиска, предоставляющее ограничение в log2(N) сравнений при идеальной балансировке и приближенное значение для АВЛ-дерева, где N - число уникальных символов, а наименьшей эффективностью обладает двоичное дерево поиска, в котором возможно вырождение некоторых цепочек узлов в списки.