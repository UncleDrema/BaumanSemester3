# Лабораторная работа №5
## Дремин Кирилл, студент ИУ7-36Б

### Описание условия задачи
Реализовать операции работы с очередью, представленной в виде массива и односвязного линейного списка, оценив преимущества и недостатки каждой реализации.
Сравнить эффективность двух реализаций при моделировании бизнес-процесса (обработка заявок в очереди).

Система состоит из обработчика ОА и очереди заявок. Новые заявки поступают по случайному закону с интервалом времени T1 (от 0 до 6),
обработка каждой занимает время в интервале T2 (от 0 до 1), и после обработки заявка поступает обратно в очередь, подвергаясь обработке 5 раз.
После 5 обработок, заявка покидает очередь.

### Описание ТЗ
#### Описание исходных данных и результатов:
Программа реализует коллекцию однотипных объектов, работающую по принципу FIFO, или очередь.
Предоставляются операции добавления элемента в очередь, удаления элемента из очереди, а также расчёта её длины, выделения и освобождения памяти

### Способ обращения к программе
Обращение происходит посредством вызова заранее скомпилированного файла и ввода через консоль

### Описание входных данных
Программа позволяет произвести настройку моделирования и его запуск.

```
1. Задать интервал T1 (интервал времени между приходом заявок)
2. Задать интервал T2 (интервал времени обработки заявок)
3. Изменить число заявок при моделировании
4. Изменить статус вывода адресов памяти при работе с очередью на основе списка
5. Изменить статус расчёта требуемой памяти (влияет на производительность!)
6. Запустить моделирование
0. Выход из программы
```

Корректный ввод - цифра от 0 до 6.

#### Описание возможных аварийных ситуаций и ошибок пользователя

1. Ввод некорректных данных
2. Ошибки выделения динамической памяти
3. Указание не имеющих смысла диапазонов (левая граница больше правой и наоборот)

### Описание внутренних СД
Программа оперирует АТД, описывающим операции над стеком:

```c
#define queue_def(subname, type) \
typedef struct queue_name(subname, type) queue_name(subname, type); \
// Добавить элемент в очередь                                 \
err_t queue_enqueue(subname, type) (queue_name(subname, type) *queue, type element); \
// Удалить элемент из очереди \
err_t queue_dequeue(subname, type) (queue_name(subname, type) *queue, type *result);   \
// Выделить память под очередь \
queue_name(subname, type) *queue_alloc(subname, type)();           \
// Освободить память, выделенную под очередь \
void queue_free(subname, type)(queue_name(subname, type) *queue);  \
// Посчитать длину очереди
size_t queue_len(subname, type) (queue_name(subname, type) *queue);\
// Посчитать размер занимаемой очередью области памяти \
size_t queue_sizeof(subname, type)(queue_name(subname, type) *queue);
```
Данный АТД является полиморфным по названию (используется для определения механизма работы) и по типу хранимых даннных
Также описанная очередь подразумевается как невладеющая - она не производит освобождения памяти, выделенной под свои элементы, при их освобождении

### Сравнение различных реализаций очереди
В ходе сравнения эффективности реализации очередей было использовано моделирование обработки заявок некой системой
Измеряемые параметры: время (в условных единицах моделируемой системы), ошибка относительно теоретических расчётов,
Затраты динамической памяти (максимальные) и реального времени на выполнение моделирования.

Было произведено моделирование обработки заявок в кол-ве 10000, результат:

| Тип    | Время (ед. вр.) |  Ошибка  |     Память     | Время (мс) |
|--------|-----------------|----------|----------------|------------|
| Теория |       30000.000 |  +0.000% |        0 bytes |       0 ms |
| Массив |       30531.547 |  +1.772% |     1508 bytes |       7 ms |
| Список |       30290.734 |  +0.969% |     1792 bytes |      72 ms |

Было произведено несколько замеров при моделировании обработки заявок в кол-ве 100000, результат:
##### 1

| Тип    | Время (ед. вр.) | Ошибка  | Память     | Время (мс) |
|--------|-----------------|---------|------------|------------|
| Теория | 300000.000      | +0.000% | 0 bytes    | 0 ms       |
| Массив | 299423.344      | -0.192% | 296 bytes  | 68 ms      |
| Список | 300793.344      | +0.264% | 6512 bytes | 1264 ms    |

#### 2

| Тип    | Время (ед. вр.) | Ошибка  | Память     | Время (мс) |
|--------|-----------------|---------|------------|------------|
| Теория | 300000.000      | +0.000% | 0 bytes    | 0 ms       |
| Массив | 300490.719      | +0.164% | 1508 bytes | 28 ms      |
| Список | 300239.281      | +0.080% | 5248 bytes | 561 ms     |

#### 3

| Тип    | Время (ед. вр.) | Ошибка  | Память     | Время (мс) |
|--------|-----------------|---------|------------|------------|
| Теория | 300000.000      | +0.000% | 0 bytes    | 0 ms       |
| Массив | 300684.062      | +0.228% | 864 bytes  | 69 ms      |
| Список | 300225.781      | +0.075% | 7376 bytes | 919 ms     |

Также для тестирования работы алгоритма было проведено моделирование ситуации с иными параметрами системы: среднее время обработки одного запроса составляет 5 единиц времени, а интервал между поступлениями запросов - 3 ед. времени

| Тип    | Время (ед. вр.) | Ошибка  | Память  | Время (мс) |
|--------|-----------------|---------|---------|------------|
| Теория | 109909.120      | +0.000% | 0 bytes | 0 ms       |
| Массив | 107304.742      | -2.370% | 0 bytes | 3 ms       |
| Список | 110611.000      | +0.639% | 0 bytes | 11 ms      |

Также для 3, 5 и 10 заявок было осуществлено моделирование с выводом адресов обрабатываемых узлов списка (результат не приводится в силу большого объёма).

Рассмотрев полученные сообщения о выделенных/освобожденных участках памяти, можно сделать вывод,
что значительной дефрагментации памяти не происходит, адреса памяти часто переиспользуются при освобождении-выделении.

### Сравнение реализаций

Реализация на основе массива является гораздо более эффективной, чем реализация на основе списка за счёт линейности расположения в памяти
и быстрого доступа к своим элементам. Однако, в отличие от реализации на основе списка, данная реализация
требует дополнительных усилий для её создания, таких как, например, разработка функции сжимания памяти обратно к началу выделенного массива
и функции увеличения доступного объёма памяти. Последняя функция может быть эффективно реализована (с минимальными накладными расходами) только
в случае, если заранее известна специфика требуемой работы, так как зависит от выбора множителя увеличения.

В данной программе высокая эффективность по занимаемой памяти достигнута как раз за счёт разработки вышеописанных дополнительных функций.
Однако может случиться так, что при слишком большом объёме выделенной под изначальный массив памяти, большая часть не будет востребована,
что приведёт к потере эффективности использования памяти. Данная проблема решается за счёт выбора малого изначального размера массива
и стратегии его увеличения по мере необходимости

### Вывод

Полученные относительно эффективности двух реализаций выводы совпадают с таковыми для структуры данных, работающей
по принципу LIFO - стека (рассмотрено в ЛР4), так что можно утверждать, что наиболее эффективной реализацией
данных структур является использование массива.

### Ответы на вопросы

1. ***Что такое FIFO и LIFO?***
   FIFO - способ организации доступа к данным в коллекции по принципу "первый вошёл - первый вышел", LIFO - "последний вошёл - первый вышел"
2. ***Каким образом и какой объем памяти выделяется под хранение очереди при различной ее реализации?***
   В случае реализации очереди на основе массива, объём выделяемой памяти под изначальный массив определяется заранее, а в дальнейшем,
   при необходимости увеличения массива, он расширяется согласно заданной стратегии, в текущей реализации - увеличение размера в 4/3 раза.
   В случае реализации очереди на основе массива память выделяется отдельно под каждый элемент, однако, помимо этого, присутствуют затраты памяти на указатели на узлы.
3. ***Каким образом освобождается память при удалении элемента из очереди при ее различной реализации?***
   В случе реализации очереди на основе массива, память при удалении элементов не освобождается, в случае реализации очереди на основе списка,
   при удалении элемента, освобождается память, выделенная под узел, его содержащий.
4. ***Что происходит с элементами очереди при ее просмотре?***
   Единственный способ просмотреть элементы очереди - удалить их, так что для полного просмотра очереди без её изменения, потребуется циклически пройти по всем элементам,
   пока не вернемся к изначальному, что, однако, невозможно будет легко отследить при неуникальности элементов очереди.
5. ***От чего зависит эффективность физической реализации очереди?***
   Эффективность физической реализации очереди зависит от эффективности её расположения в памяти (большая степень дефрагментации присуща очереди на основе списка), а также
   эффективности операций с её элементами (операции с адресной арифметикой довольно быстры, в то время как необходимость проходить весь список - медленная операция)
6. ***Каковы достоинства и недостатки различных реализаций очереди в зависимости от выполненных над ней операций?***
   В очереди на основе списка гораздо проще происходит процесс вставки и удаления элементов, т.к. нет необходимости обрабатывать случаи переполнения или "уползания" указателей pout и pin
   к концу массива, как в очереди на его основе, в то время, как очередь на основе массива эффективнее в операциях, требующих информации обо всей очереди, например - получение размера.
7. ***Что такое фрагментация данных, и в какой части ОП она возникает?***
   Фрагментация данных возникает при таком выделении динамической памяти после освобождения, при котором новая выделенная память располагается не там же, где была освобождена память до этого,
   а в другом участке памяти. Она может возникать даже несмотря на то, что участок освободившейся памяти, может быть использован для выделения памяти и приводит к замедлению доступа к памяти и повышенному её расходу (т.к. оставшиеся небольшие участки памяти не всегда могут быть использованы)
8. ***Для чего нужен алгоритм "Близнецов"?***
   Алгоритм "близнецов" позволяет дробить участок памяти на более мелкие (а также объединять их) для того, чтобы эффективно распределять память между клиентами, в то
   же время позволяя легко отслеживать свободную и занятую память, разбивая её на блоки
9. ***Какие дисциплины выделения памяти вы знаете?***
   Две основные дисциплины памяти - выделение "самого подходящего" блока (наиболее приближенного к запрашиваемому по размеру) и "первого подходящего" - первого блока, достаточного для использования клиентом
10. ***На что необходимо обратить внимание при тестировании программы?***
    На различные сценарии работы программы - при большем времени обработки и большем времени поступления данных, а также на наличие фрагментации памяти при реализации очереди списком (в случае ограниченности очередей - на переполнение)
11. ***Каким образом физически выделяется и освобождается память при динамических запросах?***
    После вызова функции выделения памяти сначала происходит поиск достаточного участка среди уже выделенной свободной памяти, в случае неудачи происходит системный вызов (с соответствующим переключением контекста в пространство ядра), после чего происходит поиск в куче
    свободной области памяти (зачастую находится большая область памяти, с расчётом на дальнейшее выделение динамическое памяти), клиент же получает указатель на выделенную область памяти,
    которая теперь помечена как занятая, в случае неудачи выделения - возвращается NULL
    При вызове функции освобождения памяти происходит поиск указанной области среди всех занятых областей памяти, дальше область помечается как свободная и может быть использована в дальнейшем
   