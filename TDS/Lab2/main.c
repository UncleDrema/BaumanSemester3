// This is a personal academic project. Dear PVS-Studio, please check it.

// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include "sort.h"
#include <locale.h>
#include "book.h"
#include "utils.h"
#include "benchmark.h"
#define MENU_SIZE 13
#define STR_BUF 256

void gen_random_data(FILE *f, size_t count);

void recalculate_keys(table_key_t **keys, book_t *arr, int len);

void print_book_table_entry(book_t *book, int ind);

int main()
{
    srand(time(NULL));
    setlocale(LC_ALL, "Rus");

    int mode;
    bool stop = false;
    bool dont_stop = true;

    book_t *arr = NULL;
    table_key_t *key_arr = NULL;
    bool key_formed = false;
    int len = 0;

    while (!stop)
    {
        if (!dont_stop)
        {
            printf("Нажмите Enter, чтобы продолжить...");
            skip_to_nl(stdin);
        }
        dont_stop = false;

        if (len == 0)
        {
            SAFE_FREE(arr);
        }

        char *menu[MENU_SIZE] = {
                "Создать файл, случайно заполненный данными",
                "Считать данные из файла в память",
                "Записать текущие данные в файл",
                "Вывести данные из памяти",
                "Добавить запись",
                "Удалить запись",
                "Провести замеры времени сортировки двумя способами",
                "Отсортировать таблицу",
                "Отсортировать таблицу ключей",
                "Вывести таблицу",
                "Вывести таблицу ключей",
                "Вывести таблицу по ключам",
                "Вывести отечественную тех. литературу по указанной отрасли указанного года"
        };
        for (int i = 0; i < MENU_SIZE; ++i)
        {
            printf("%d. %s\n", i + 1, menu[i]);
        }

        printf("0. Выход из программы\n");
        printf("Данные %s, длина: %d\n", arr == NULL ? "отсутствуют" : "присутствуют", len);
        printf("Выберите пункт меню: ");# Лабораторная работа №2
## Дремин Кирилл, студент ИУ7-36Б

### Описание условия задачи
Необходимо создать таблицу, заполненную не менее чем 40 записями с вариантной частью. Требуется произвести поиск информации по заданному вариантному полю, упорядочивание таблицы и оценку эффективности упорядочивания различными методами.

### Описание ТЗ
#### Описание исходных данных и результатов:
(типы, форматы, точность, способ передачи, ограничения)
Программа оперирует записями о книгах, содержащими автора, издательство, название книги, количество страниц, далее, в зависимости от жанра литературы:
1. Техническая - отрасль хозяйства, вид тех. литературы (переведённая или отечественная), год издания
2. Художественная литература (пьеса, рассказ или стихи)
3. Детская литература (сказка или детские стихи)

Ключевым значением записи выбрано количество страниц.

Также программа оперирует таким понятием, как таблица ключей, она представляет собой таблицу, соответствующую таблице записей, однако хранящей только индекс элемента в основной таблице и его ключевое значение.

#### Описание задачи, реализуемой программой
Программа предоставляет доступ к различным операциям над таблицей: загрузка/выгрузка таблицы в/из файла, генерация случайных данных для тестирования, вставка и удаление записей, сортировка таблицы/таблицы ключей, вывод таблицы, вывод таблицы ключей, вывод таблицы по ключам, замер эффективности работы алгоритмов сортировки.

Также программа может осуществлять поиск по запросу - поиск отечественной технической литературы, по заданной отрасли хозяйства и году издания.

#### Способ обращения к программе
Обращение к программе происходит путём работы с текстовым меню через консоль, доступные пункты меню:
0. Выход из программы
1. Создать файл, случайно заполненный данными
2. Считать данные из файла в память
3. Записать текущие данные в файл
4. Вывести данные из памяти
5. Добавить запись
6. Удалить запись
7. Провести замеры времени сортировки двумя способами
8. Отсортировать таблицу
9. Отсортировать таблицу ключей
10. Вывести таблицу
11. Вывести таблицу ключей
12. Вывести таблицу по ключам
13. Вывести отечественную тех. литературу по указанной отрасли указанного года

#### Описание возможных аварийных ситуаций и ошибок пользователя
1. В случае превышения допустимого числа символов для строковых полей (либо ввода пустой строки), произойдёт потеря информации. Для фамилии автора и издательства: 15 символов, для названия - 31 символ.
2. Ввод недопустимых данных (отрицательные числа там, где требуются положительные, например), произойдёт ошибка ввода и пользователю будет необходимо заново повторить попытку ввода
3. Ошибки открытия файла на чтение/запись
4. Ошибка выделения памяти


### Описание внутренних СД
Программа оперирует таблицей записей следующего вида:
```c
typedef struct
{
    /// Фамилия автора
    char author[AUTHOR_NAME_LEN];
    /// Издательство
    char publisher[PUBLISHER_NAME_LEN];
    /// Название книги
    char title[TITLE_NAME_LEN];
    /// Количество страниц
    unsigned int page_count;
    /// Жанр книги
    genre_t genre;
    /// Специфичные для жанра данные
    union {
        /// Техническая литература
        struct {
            /// Отрасль хозяйства
            industry_type industry;
            /// Вид технической литературы
            tech_type_t type;
            /// Год издания
            unsigned short int year;
        } tech;
        /// Художественная литература
        struct
        {
            /// Вид художественной литературы
            fiction_type_t type;
        } fiction;
        /// Детская литература
        struct
        {
            // Вид детской литературы
            child_type_t type;
        } child;
    } literature_kind;
} book_t;
```

Для реализации таблицы ключей используется следующая структура данных:
```c
/// Структура для хранения ключей таблицы
typedef struct
{
    /// Индекс в базовой таблице
    unsigned int base_table_index;
    /// Число страниц
    unsigned int page_count;
} table_key_t;
```

### Сравнение алгоритмов сортировки
При проведении замеров эффективности использовались 3 варианат сортировки таблицы:
а) Быстрая сортировка всей таблицы
б) Быстрая сортировка с использованием таблицы ключей
в) Сортировка вставками с использоавнием таблицы ключей

Эффективность сортировки а) взята за 100%
Тогда результаты сравнения эффективности примут следующий вид:

2 записи в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 100.00% | 91.30% |
| в | 140.00% | 91.30% |

(в основном на результат влияют погрешности измерения)

10 записей в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 185.29% | 91.30% |
| в | 75.90% | 91.30% |

20 записей в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 159.42% | 91.30% |
| в | 43.14% | 91.30% |

40 записей в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 168.00% | 91.30% |
| в | 28.23% | 91.30% |

### Выводы
Использование типа с варантной частью позволяет более эффективно компоновать различные схожие друг с другом структуры данных, взамен на некоторое усложение работы с ними и увеличение среднего размера.

Исходя из полученных в ходе тестирования эффективности сортировки таблицы записей результатов, можно сделать вывод, что использование дополнительной таблицы ключей для сортировки позволяет гораздо эффективнее сортировать таблицу записей, за счёт уменьшения размера перемещаемых объёмов памяти. Потеря эффективности по памяти при этом незначительна и стремится к нулю при увеличении размера одной записи.

### Ответы на вопросы

##### 1. Как выделяется память под вариантную часть записи?
Объём записи под вариантную часть записи высчитывается, как максимум размера среди возможных вариантов.

#### 2. Что будет, если в вариантную часть ввести данные, не соответствующие описанным
Так как вариантная часть по сути предоставляет лишь разный интерфейс доступа к одному и тому же участку памяти, внесение некорректных данных приведёт к неверной их интерпреиации и потере смысла значения.

#### 3. Кто должен следить за правильностью выполнения операций с вариантной частью записи?
Контроль за правильностью выполнения операций с вариантной частью записи осуществляется программистом.

#### 4. Что представляет собой таблица ключей, зачем она нужна?
Таблица ключей представляет собой вспомогательную таблицу записей, хранящих в себе индексы соответствующих записей в исходной таблице, а так же значение ключевого для них поля. Таблица ключей может быть тривиально построена на основе исходной таблицы, а в дальнейшем - может быть отсортирована и использована для вывода отсортированной исходной таблицы, путём использования индексов записей исходной таблицы.

#### 5. В каких случаях эффективнее обрабатывать данные в самой таблице, а когда - использовать таблицу ключей?
Обработка с использованием таблицы ключей эффективнее на любом размере таблицы при условии, что размер записи в таблице ключей сильно меньше размера записи в таблице, так как затраты времени на перемещение данных будут сильно снижены при небольших дополнительных затратах памяти
        if (scanf("%d", &mode) != 1 || mode < 0 || mode > MENU_SIZE)
        {
            skip_to_nl(stdin);
            continue;
        }
        skip_to_nl(stdin);

        switch (mode) {
            case 1: {
                dont_stop = true;
                char buf[STR_BUF];
                printf("Введите путь к создаваемому файлу: ");
                if (fgets(buf, STR_BUF, stdin) == 0) {
                    printf("Ошибка ввода пути к файлу\n");
                    break;
                }
                remove_nl(buf);

                FILE *f = fopen(buf, "w");
                if (f == NULL) {
                    printf("Ошибка открытия файла\n");
                    break;
                }

                size_t amount;
                printf("Введите число записей для генерации: ");
                if (scanf("%zu", &amount) != 1 || amount == 0) {
                    printf("Некорректный ввод\n");
                    fclose(f);
                    break;
                }

                gen_random_data(f, amount);

                fclose(f);
                f = fopen(buf, "r");

                err_t rc = read_books(f, &arr, &len);

                if (rc == OK) {
                    puts("Файл заполнен данными и считан в память!");
                } else {
                    puts("Ошибка считывания данных!");
                }

                fclose(f);
                break;
            }
            case 2: {
                dont_stop = true;
                char buf[STR_BUF];
                printf("Введите путь к читаемому файлу: ");
                if (fgets(buf, STR_BUF, stdin) == 0) {
                    printf("Ошибка ввода пути к файлу\n");
                    break;
                }
                remove_nl(buf);

                FILE *f = fopen(buf, "r");
                if (f == NULL) {
                    printf("Ошибка открытия файла\n");
                    break;
                }

                err_t rc = read_books(f, &arr, &len);

                if (rc == OK) {
                    puts("Файл считан в память!");
                } else {
                    puts("Ошибка считывания данных!");
                }
                key_formed = false;

                fclose(f);
                break;
            }
            case 3:
            {
                dont_stop = true;
                char buf[STR_BUF];
                printf("Введите путь к файлу для записи: ");
                if (fgets(buf, STR_BUF, stdin) == 0) {
                    printf("Ошибка ввода пути к файлу\n");
                    break;
                }
                remove_nl(buf);

                FILE *f = fopen(buf, "w");
                if (f == NULL) {
                    printf("Ошибка открытия файла\n");
                    break;
                }

                print_books(f, len, arr, false);

                fclose(f);
                break;
            }
            case 4:
            {
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }
                print_books(stdout, len, arr, true);
                break;
            }
            case 5:
            {
                dont_stop = true;
                book_t book;
                err_t rc = read_book(stdin, &book, stdout);

                if (rc != OK)
                {
                    puts("Ошибка ввода!");
                    break;
                }

                book_t *new = realloc(arr, (len + 1) * sizeof(book_t));
                if (new == NULL)
                {
                    puts("Ошибка выделения памяти!");
                    break;
                }

                arr = new;
                arr[len] = book;
                len++;
                key_formed = false;
                break;
            }
            case 6:
            {
                dont_stop = true;
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }
                int index;

                printf("Введите номер записи для удаления: ");
                if (scanf("%d", &index) != 1 || index <= 0 || index > len)
                {
                    puts("Ошибка ввода!");
                    break;
                }
                skip_to_nl(stdin);
                index--;
                void *deleting = at_index(arr, index, sizeof(book_t));
                void *last = at_index(arr, len - 1, sizeof(book_t));

                memcpy(deleting, last, sizeof(book_t));

                book_t *new = realloc(arr, (len - 1) * sizeof(book_t));
                len--;
                if (new == NULL && len != 0)
                {
                    puts("Ошибка обрезки массива!");
                    break;
                }

                puts("Элемент удалён!");
                arr = new;
                key_formed = false;
                break;
            }
            case 7:
            {
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }
                benchmark(arr, len);
                break;
            }
            case 8:
            {
                dont_stop = true;
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }
                qsort(arr, len, sizeof(book_t), book_cmp);
                puts("Таблица отсортирована!");
                key_formed = false;
                // sort table
                break;
            }
            case 9:
            {
                dont_stop = true;
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }

                if (!key_formed)
                {
                    puts("Таблица ключей пересчитана!");
                    recalculate_keys(&key_arr, arr, len);
                    key_formed = true;
                }

                qsort(key_arr, len, sizeof(table_key_t), key_cmp);
                puts("Таблица ключей отсортирована!");
                // sort key table
                break;
            }
            case 10:
            {
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }

                puts("-----------------------------------------------------------------------------------------------------------------------------------------");
                printf("|%4s|%16s|%16s|%32s|%6s|%7s|%8s|%10s|%6s|%10s|%10s|\n", "Ind", "Author", "Publisher", "Title", "Pages", "Genre", "Industry", "Tech type", "Year", "Fict type", "Child type");
                puts("-----------------------------------------------------------------------------------------------------------------------------------------");
                for (int i = 0; i < len; ++i) {
                    print_book_table_entry(arr + i, i);
                }
                puts("-----------------------------------------------------------------------------------------------------------------------------------------");
                // print table
                break;
            }
            case 11:
            {
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }
                if (!key_formed)
                {
                    puts("Таблица ключей пересчитана!");
                    recalculate_keys(&key_arr, arr, len);
                    key_formed = true;
                }

                puts("---------------------");
                printf("|%4s|%8s|%4s|\n", "Ind", "Base Ind", "Pages");
                puts("---------------------");
              # Лабораторная работа №2
## Дремин Кирилл, студент ИУ7-36Б

### Описание условия задачи
Необходимо создать таблицу, заполненную не менее чем 40 записями с вариантной частью. Требуется произвести поиск информации по заданному вариантному полю, упорядочивание таблицы и оценку эффективности упорядочивания различными методами.

### Описание ТЗ
#### Описание исходных данных и результатов:
(типы, форматы, точность, способ передачи, ограничения)
Программа оперирует записями о книгах, содержащими автора, издательство, название книги, количество страниц, далее, в зависимости от жанра литературы:
1. Техническая - отрасль хозяйства, вид тех. литературы (переведённая или отечественная), год издания
2. Художественная литература (пьеса, рассказ или стихи)
3. Детская литература (сказка или детские стихи)

Ключевым значением записи выбрано количество страниц.

Также программа оперирует таким понятием, как таблица ключей, она представляет собой таблицу, соответствующую таблице записей, однако хранящей только индекс элемента в основной таблице и его ключевое значение.

#### Описание задачи, реализуемой программой
Программа предоставляет доступ к различным операциям над таблицей: загрузка/выгрузка таблицы в/из файла, генерация случайных данных для тестирования, вставка и удаление записей, сортировка таблицы/таблицы ключей, вывод таблицы, вывод таблицы ключей, вывод таблицы по ключам, замер эффективности работы алгоритмов сортировки.

Также программа может осуществлять поиск по запросу - поиск отечественной технической литературы, по заданной отрасли хозяйства и году издания.

#### Способ обращения к программе
Обращение к программе происходит путём работы с текстовым меню через консоль, доступные пункты меню:
0. Выход из программы
1. Создать файл, случайно заполненный данными
2. Считать данные из файла в память
3. Записать текущие данные в файл
4. Вывести данные из памяти
5. Добавить запись
6. Удалить запись
7. Провести замеры времени сортировки двумя способами
8. Отсортировать таблицу
9. Отсортировать таблицу ключей
10. Вывести таблицу
11. Вывести таблицу ключей
12. Вывести таблицу по ключам
13. Вывести отечественную тех. литературу по указанной отрасли указанного года

#### Описание возможных аварийных ситуаций и ошибок пользователя
1. В случае превышения допустимого числа символов для строковых полей (либо ввода пустой строки), произойдёт потеря информации. Для фамилии автора и издательства: 15 символов, для названия - 31 символ.
2. Ввод недопустимых данных (отрицательные числа там, где требуются положительные, например), произойдёт ошибка ввода и пользователю будет необходимо заново повторить попытку ввода
3. Ошибки открытия файла на чтение/запись
4. Ошибка выделения памяти


### Описание внутренних СД
Программа оперирует таблицей записей следующего вида:
```c
typedef struct
{
    /// Фамилия автора
    char author[AUTHOR_NAME_LEN];
    /// Издательство
    char publisher[PUBLISHER_NAME_LEN];
    /// Название книги
    char title[TITLE_NAME_LEN];
    /// Количество страниц
    unsigned int page_count;
    /// Жанр книги
    genre_t genre;
    /// Специфичные для жанра данные
    union {
        /// Техническая литература
        struct {
            /// Отрасль хозяйства
            industry_type industry;
            /// Вид технической литературы
            tech_type_t type;
            /// Год издания
            unsigned short int year;
        } tech;
        /// Художественная литература
        struct
        {
            /// Вид художественной литературы
            fiction_type_t type;
        } fiction;
        /// Детская литература
        struct
        {
            // Вид детской литературы
            child_type_t type;
        } child;
    } literature_kind;
} book_t;
```

Для реализации таблицы ключей используется следующая структура данных:
```c
/// Структура для хранения ключей таблицы
typedef struct
{
    /// Индекс в базовой таблице
    unsigned int base_table_index;
    /// Число страниц
    unsigned int page_count;
} table_key_t;
```

### Сравнение алгоритмов сортировки
При проведении замеров эффективности использовались 3 варианат сортировки таблицы:
а) Быстрая сортировка всей таблицы
б) Быстрая сортировка с использованием таблицы ключей
в) Сортировка вставками с использоавнием таблицы ключей

Эффективность сортировки а) взята за 100%
Тогда результаты сравнения эффективности примут следующий вид:

2 записи в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 100.00% | 91.30% |
| в | 140.00% | 91.30% |

(в основном на результат влияют погрешности измерения)

10 записей в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 185.29% | 91.30% |
| в | 75.90% | 91.30% |

20 записей в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 159.42% | 91.30% |
| в | 43.14% | 91.30% |

40 записей в таблице

| Сортировка | Время | Память |
| ---------- | ----- | ------ |
| а | 100.00% | 100.00% |
| б | 168.00% | 91.30% |
| в | 28.23% | 91.30% |

### Выводы
Использование типа с варантной частью позволяет более эффективно компоновать различные схожие друг с другом структуры данных, взамен на некоторое усложение работы с ними и увеличение среднего размера.

Исходя из полученных в ходе тестирования эффективности сортировки таблицы записей результатов, можно сделать вывод, что использование дополнительной таблицы ключей для сортировки позволяет гораздо эффективнее сортировать таблицу записей, за счёт уменьшения размера перемещаемых объёмов памяти. Потеря эффективности по памяти при этом незначительна и стремится к нулю при увеличении размера одной записи.

### Ответы на вопросы

##### 1. Как выделяется память под вариантную часть записи?
Объём записи под вариантную часть записи высчитывается, как максимум размера среди возможных вариантов.

#### 2. Что будет, если в вариантную часть ввести данные, не соответствующие описанным
Так как вариантная часть по сути предоставляет лишь разный интерфейс доступа к одному и тому же участку памяти, внесение некорректных данных приведёт к неверной их интерпреиации и потере смысла значения.

#### 3. Кто должен следить за правильностью выполнения операций с вариантной частью записи?
Контроль за правильностью выполнения операций с вариантной частью записи осуществляется программистом.

#### 4. Что представляет собой таблица ключей, зачем она нужна?
Таблица ключей представляет собой вспомогательную таблицу записей, хранящих в себе индексы соответствующих записей в исходной таблице, а так же значение ключевого для них поля. Таблица ключей может быть тривиально построена на основе исходной таблицы, а в дальнейшем - может быть отсортирована и использована для вывода отсортированной исходной таблицы, путём использования индексов записей исходной таблицы.

#### 5. В каких случаях эффективнее обрабатывать данные в самой таблице, а когда - использовать таблицу ключей?
Обработка с использованием таблицы ключей эффективнее на любом размере таблицы при условии, что размер записи в таблице ключей сильно меньше размера записи в таблице, так как затраты времени на перемещение данных будут сильно снижены при небольших дополнительных затратах памяти  table_key_t temp;
                for (int i = 0; i < len; ++i) {
                    temp = key_arr[i];
                    printf("|%4d|%8u|%5u|\n", i, temp.base_table_index, temp.page_count);
                }

                // print key table
                break;
            }
            case 12:
            {
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }

                if (!key_formed)
                {
                    puts("Таблица ключей пересчитана!");
                    recalculate_keys(&key_arr, arr, len);
                    key_formed = true;
                }

                puts("-----------------------------------------------------------------------------------------------------------------------------------------");
                printf("|%4s|%16s|%16s|%32s|%6s|%7s|%8s|%10s|%6s|%10s|%10s|\n", "Ind", "Author", "Publisher", "Title", "Pages", "Genre", "Industry", "Tech type", "Year", "Fict type", "Child type");
                puts("-----------------------------------------------------------------------------------------------------------------------------------------");
                for (int i = 0; i < len; ++i) {
                    int ind = (int)key_arr[i].base_table_index;
                    print_book_table_entry(arr + ind, ind);
                }
                puts("-----------------------------------------------------------------------------------------------------------------------------------------");

                // print table by keys
                break;
            }
            case 13:
            {
                if (len <= 0)
                {
                    puts("Нет данных!");
                    break;
                }

                industry_type industry;
                unsigned short year;
                // print by query
                printf("Please, input industry code: ");
                if (scanf("%d", &industry) != 1)
                {
                    puts("Ошибка ввода!");
                }

                printf("Please, input publishment year: ");
                if (scanf("%hu", &year) != 1)
                {
                    puts("Ошибка ввода!");
                }

                puts("Подходящие записи в таблице:");
                int count = 0;
                puts("-----------------------------------------------------------------------------------------------------------------------------------------");
                printf("|%4s|%16s|%16s|%32s|%6s|%7s|%8s|%10s|%6s|%10s|%10s|\n", "Ind", "Author", "Publisher", "Title", "Pages", "Genre", "Industry", "Tech type", "Year", "Fict type", "Child type");
                puts("-----------------------------------------------------------------------------------------------------------------------------------------");
                book_t temp;
                for (int i = 0; i < len; ++i) {
                    temp = arr[i];
                    if (temp.literature_kind.tech.industry == industry && temp.literature_kind.tech.year == year)
                    {
                        print_book_table_entry(arr + i, count++);
                    }
                }
                if (count == 0)
                {
                    puts("Не найдено!");
                }
                puts("-----------------------------------------------------------------------------------------------------------------------------------------");

                break;
            }
            case 0:
                stop = true;
                break;
        }
    }

    SAFE_FREE(arr);

    return 0;
}

void recalculate_keys(table_key_t **keys, book_t *arr, int len)
{
    SAFE_FREE(*keys);

    table_key_t *new = calloc(len, sizeof(table_key_t));
    *keys = new;

    table_key_t temp = {0, 0};
    for (int i = 0; i < len; ++i)
    {
        temp.base_table_index = i;
        temp.page_count = arr[i].page_count;
        new[i] = temp;
    }
}

void gen_random_data(FILE *f, size_t count)
{
    book_t book;

    for (size_t i = 0; i < count; i++)
    {
        gen_random_book(&book);
        print_book(f, &book, false);
    }
}

void print_book_table_entry(book_t *book, int ind)
{
    char *genre, *tech_type = "", *fiction_type = "", *child_type = "";
    char industry[STR_BUF] = "";
    char year[STR_BUF] = "";
    switch (book->genre) {
        case TECH:
            genre = "tech";
            snprintf(industry, sizeof(industry), "%d", book->literature_kind.tech.industry);
            snprintf(year, sizeof(year), "%u", book->literature_kind.tech.year);
            switch (book->literature_kind.tech.type) {
                case NATIONAL:
                    tech_type = "national";
                    break;
                case TRANSLATED:
                    tech_type = "translated";
                    break;
            }
            break;
        case FICTION:
            genre = "fiction";
            switch (book->literature_kind.fiction.type) {
                case NOVEL:
                    fiction_type = "novel";
                    break;
                case PLAY:
                    fiction_type = "play";
                    break;
                case POEM:
                    fiction_type = "poem";
                    break;
            }
            break;
        case CHILD:
            genre = "child";
            switch (book->literature_kind.child.type) {
                case FAIRY_TALE:
                    child_type = "fairy tale";
                    break;
                case CHILD_POEM:
                    child_type = "child poem";
                    break;
            }
            break;
        default:
            genre = "UNKNOWN";
            break;
    }



    printf("|%4d|%16s|%16s|%32s|%6u|%7s|%8s|%10s|%6s|%10s|%10s|\n", ind, book->author, book->publisher, book->title, book->page_count, genre, industry, tech_type, year, fiction_type, child_type);
}